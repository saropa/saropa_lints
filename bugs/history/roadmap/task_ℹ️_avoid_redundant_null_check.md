# Task: `avoid_redundant_null_check`

## Summary
- **Rule Name**: `avoid_redundant_null_check`
- **Tier**: Recommended
- **Severity**: INFO
- **Status**: Planned
- **Source**: ROADMAP.md §Code Quality

## Problem Statement
Under Dart's sound null safety system, variables declared with a non-nullable type
(e.g., `String`, `int`, `MyClass`) can never hold `null` at runtime. The compiler
enforces this guarantee statically. Consequently, writing `if (x != null)` or
`x == null` when `x` has a non-nullable static type is logically impossible —
the condition is always `true` (for `!= null`) or always `false` (for `== null`).

Such redundant checks:
- Mislead readers into thinking the variable could be null.
- Indicate a developer misunderstanding of the type system or a leftover from
  migrating pre-null-safety code.
- Add dead code branches (the else of `if (x != null)` is unreachable).
- Trigger "always true/false" warnings in strict analysis modes.

This rule surfaces these checks as INFO-level diagnostics to help teams clean up
post-migration code and prevent new redundant checks from being introduced.

## Description (from ROADMAP)
Flag `x != null` or `x == null` expressions where `x` has a statically non-nullable type.

## Trigger Conditions
1. A `BinaryExpression` has operator `==` or `!=`.
2. One operand is a `NullLiteral`.
3. The other operand has a static type that is non-nullable (i.e., `type.nullabilitySuffix`
   is `NullabilitySuffix.none`).
4. The expression is not inside a `operator ==` body (that case is handled by
   `avoid_null_checks_in_equality_operators`).
5. The operand is not of type `dynamic` or `Object?` — those genuinely can be null.

## Implementation Approach

### AST Visitor
```dart
context.registry.addBinaryExpression((node) { ... });
```

### Detection Logic
1. Check `node.operator.type` is `TokenType.EQ_EQ` or `TokenType.BANG_EQ`.
2. Identify the null operand and the non-null operand. One must be a `NullLiteral`;
   extract the other as `candidate`.
3. Retrieve `candidate.staticType`. If null (unresolved), skip.
4. Check `candidateType.nullabilitySuffix == NullabilitySuffix.none`.
5. Also verify `candidateType` is not `DynamicType` or `InvalidType` — these are escape
   hatches from the type system and may hold null at runtime.
6. Verify the binary expression is not itself within a method named `operator ==` — those
   are handled by the sibling rule.
7. Report the binary expression node.

## Code Examples

### Bad (triggers rule)
```dart
void process(String name) {
  if (name != null) {           // always true — String is non-nullable
    print(name.toUpperCase());
  }
}
```

```dart
int add(int a, int b) {
  if (a == null) return 0;      // always false — int is non-nullable
  return a + b;
}
```

```dart
class Service {
  final Repository repo;

  Service(this.repo);

  bool isReady() => repo != null;   // always true
}
```

### Good (compliant)
```dart
void process(String? name) {
  if (name != null) {           // ok: nullable type
    print(name.toUpperCase());
  }
}

void safeDivide(int a, int? b) {
  if (b == null) return;        // ok: nullable type
  print(a / b);
}

dynamic fetchValue() => null;
void check() {
  final v = fetchValue();
  if (v == null) return;        // ok: dynamic type
}
```

## Edge Cases & False Positives
- **`dynamic` type**: Variables with type `dynamic` can hold null at runtime even without
  a `?` suffix. The rule must NOT flag `dynamic` variables. Check
  `type is DynamicType` before reporting.
- **`Object` type**: `Object` (non-nullable) cannot hold null; flag it. `Object?` can;
  do not flag.
- **Type parameters**: A generic type parameter `T` may or may not be nullable depending
  on bounds. If `T extends Object`, it is non-nullable — flag. If `T` has no bound or
  `T extends Object?`, skip.
- **Promoted types**: After a null check in a conditional, the type may be promoted.
  This rule operates on the static type at the expression location; the analyzer's
  promoted type information should be accessible via `node.staticType` after promotion.
- **`late` variables**: A `late` variable has a non-nullable declared type but throws
  `LateInitializationError` (not null) if uninitialized. The null check is still
  logically always-true or always-false. Flag it with a note in the diagnostic message.
- **Compound conditions**: `x != null && x.length > 0` — flag only the `x != null`
  sub-expression when `x` is non-nullable; leave the rest of the condition intact.
- **`identical(x, null)`**: This is a different pattern not covered by this rule. Leave
  it to a separate rule or `avoid_null_checks_in_equality_operators`.
- **Operator `==` with a non-null type on `Object` parameter**: See sibling rule.
- **Generated code**: Files generated by `build_runner` often contain such checks from
  templates; consider allowing suppression via `// ignore:` or checking for
  `// GENERATED CODE` file headers.

## Unit Tests

### Should Trigger (violations)
```dart
void f1(int x) {
  if (x != null) print(x);     // LINT: int is non-nullable
}

void f2(String s) {
  final check = s == null;     // LINT: String is non-nullable
  print(check);
}

class MyClass {
  final List<int> items;
  MyClass(this.items);
  bool hasItems() => items != null;  // LINT: List<int> non-nullable
}
```

### Should NOT Trigger (compliant)
```dart
void f3(int? x) {
  if (x != null) print(x);    // ok: nullable
}

void f4(dynamic d) {
  if (d == null) return;       // ok: dynamic
}

void f5(Object? o) {
  if (o != null) print(o);    // ok: Object? is nullable
}
```

## Quick Fix
**Remove the redundant null check and simplify the surrounding code.**

For `if (x != null) { body }` where `x` is non-nullable:
```dart
// Before
if (name != null) {
  print(name.toUpperCase());
}

// After
print(name.toUpperCase());
```

For `if (x == null) return;` (guard clause with always-false condition):
```dart
// Before
if (repo == null) return;

// After
(remove the statement entirely)
```

For a boolean expression `x != null` used as a value:
```dart
// Before
bool isReady() => repo != null;

// After
bool isReady() => true;
```

The auto-fix for the last case (replacing with `true` or `false`) may feel odd —
offer it but also suggest the developer delete the check entirely if the value is unused.

## Notes & Issues
- This rule should be coordinated carefully with the Dart analyzer's own
  `unnecessary_null_comparison` lint. If that SDK lint is already enabled in
  `analysis_options.yaml`, this rule would be a duplicate. Verify the SDK lint coverage
  and either:
  a) Skip this rule in favor of the SDK lint at the Recommended tier, or
  b) Differentiate by providing a better message or a quick fix the SDK lint lacks.
- The `NullabilitySuffix` enum from `package:analyzer` is the correct mechanism to check
  for nullability; do not use string-based type name inspection.
- Report at INFO severity (not WARNING) because false positives are possible in
  partially-migrated codebases or generated files.
